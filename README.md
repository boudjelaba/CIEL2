```cmd
git config --global color.diff auto
git config --global color.status auto
git config --global color.branch auto
```


https://www.elektormagazine.fr/articles/micropython-pour-l-esp32-et-ses-copains-partie-1

# CIEL2

[![D√©veloppement Web](https://img.shields.io/badge/HTML-CSS-yellow)](https://www.w3.org/)
[![PHP SQL](https://img.shields.io/badge/PHP-MySQL-8A2BE2)](https://www.php.net/)

[![Robot NAO](https://img.shields.io/badge/Robot%20NAO-f2003c)](https://www.aldebaran.com/fr/nao)
[![C++ Arduino](https://img.shields.io/badge/Arduino-teal)](https://docs.arduino.cc/)
[![ESP32](https://img.shields.io/badge/ESP32-green)](https://www.espressif.com/en/products/socs/esp32)
[![RPi](https://img.shields.io/badge/Paspberry%20Pi-1b4d3e)](https://www.raspberrypi.com/)

[![C CPP](https://img.shields.io/badge/C-C++-7b68ee)](https://www.cpp.org/)
[![Python Versions](https://img.shields.io/badge/Python-3-blue)](https://www.python.org/)
[![PS CMD](https://img.shields.io/badge/>__ps->\__cmd-bebebe)](https://www.carnus.fr/)
[![JS JSON](https://img.shields.io/badge/JS-JSON-cb410b)](https://www.carnus.fr/)

[![GitHub git](https://img.shields.io/badge/GitHub-git-fd5800)](https://www.carnus.fr/)
[![Markdown](https://img.shields.io/badge/M%20‚¨á-191970)](https://www.carnus.fr/)

[![Visual Studio Code](https://img.shields.io/badge/Visual%20Studio%20Code-2a52be)](https://www.carnus.fr/)
[![Code Blocks](https://img.shields.io/badge/Code::Blocks-008000)](https://www.carnus.fr/)
[![Jupyter](https://img.shields.io/badge/Jupyter%20NoteBook-ff8c00)](https://www.carnus.fr/)

# ‚¨áÔ∏è <cite><font color="(0,68,88)">Mini-Projets CIEL-2</font></cite>

<a href="https://carnus.fr"><img src="https://img.shields.io/badge/Carnus%20Enseignement Sup√©rieur-F2A900?style=for-the-badge" /></a>
<a href="https://carnus.fr"><img src="https://img.shields.io/badge/BTS%20CIEL-2962FF?style=for-the-badge" /></a>

    Professeur - K. B.

### Contact : [Mail](mailto:lycee@carnus.fr)
---

<a id="LOG"></a>
## <cite><font color="blue"> Logiciels et supports : </font></cite>

[![C++ Arduino](https://img.shields.io/badge/C++-Arduino-teal)](https://docs.arduino.cc/)
[![D√©veloppement Web](https://img.shields.io/badge/HTML-CSS-yellow)](https://www.w3.org/)
[![PHP SQL](https://img.shields.io/badge/PHP-MySQL-8A2BE2)](https://www.php.net/)
[![Python Versions](https://img.shields.io/badge/Python-3-blue)](https://www.python.org/)
[![RPi](https://img.shields.io/badge/Paspberry%20Pi-red)](https://www.raspberrypi.com/)
[![ESP32](https://img.shields.io/badge/ESP32-green)](https://www.espressif.com/en/products/socs/esp32)

---

### Table des mati√®res :

* <a href="#LOG">Logiciels et supports</a>
* <a href="#PP">Pr√©sentation </a>
* <a href="#CC">Cahier des charges et expression du besoin</a>
* <a href="#PR">Pr√©requis</a>
* <a href="#OB">Objectifs </a>
* <a href="#PDL">Processus de d√©veloppement logiciel </a>
    * <a href="#PDLE">Exemples d‚Äô√©tapes</a>
* <a href="#POO">Classes C++ </a>

---

<a id="PP"></a>
## <cite><font color="#F2A900"> Pr√©sentation : </font></cite>

‚úçüèº Le projet consiste √† r√©aliser une interface de gestion (dashboard) dynamique contr√¥lable par l‚Äôoutil informatique. Ce syst√®me est compos√© de plusieurs points de contr√¥le r√©partis dans des endroits cl√© de la salle 215.

<a id="CC"></a>
## <cite><font color="#F2A900"> Cahier des charges et expression du besoin : </font></cite>

Le lyc√©e d√©sire se doter d'un syst√®me de gestion des capteurs install√©s dans la salle 215.

Le projet se voudra √©volutif, il sera possible dans l'avenir d'ajouter des points de contr√¥le et de gestion (en fonction des besoins, du budget et de la structure r√©seau mise en place).

Les points de contr√¥le seront utilis√©s afin de renseigner les √©tudiants et les enseignants sur les valeurs fournies par des capteurs connect√©s √† une carte Raspberry Pi.

<a id="PR"></a>
## <cite><font color="blue"> Pr√©requis : </font></cite>

* Des connaissances en programmation 
* Des connaissances en d√©veloppement Web
* Des conaissances en r√©seaux


<a id="OB"></a>
## <cite><font color="blue"> Objectifs : </font></cite>

* Travailler en √©quipe et g√©rer un projet
* Produire de la documentation technique
* Approfondir les connaissances en programmation et en r√©seaux


---

<a id="PDL"></a>
## Processus de d√©veloppement logiciel
* Un processus de d√©veloppement d√©crit une m√©thode qui permet de construire, d√©ployer et √©ventuellement maintenir ou faire √©voluer un logiciel. ‚úåüèº

<a id="PDLE"></a>
### Exemples d‚Äô√©tapes :
- Exigences, Analyse, Conception, Mise en ≈ìuvre (impl√©mentation), Test
- Besoin/Faisabilit√©, √âlaboration, Fabrication, Transition/Test

---
---

<a id="POO"></a>
## Programmation Orient√©e Objet (C++)

[![C CPP](https://img.shields.io/badge/C-C++-7b68ee)](https://www.cpp.org/)

[![Visual Studio Code](https://img.shields.io/badge/Visual%20Studio%20Code-2a52be)](https://www.carnus.fr/)
[![Code Blocks](https://img.shields.io/badge/Code::Blocks-008000)](https://www.carnus.fr/)


# C++ : Programmation orient√©e objet

- **Classe** : structure rassemblant √† la fois les donn√©es (*attributs*) et les m√©thodes pour les manipuler.
    + un ensemble d‚Äôattributs (donn√©es membres) d√©crivant sa structure.
    + un ensemble d‚Äôop√©rations (m√©thodes, ou fonctions membres) qui lui sont applicables.
- **Objet** : un objet est une instance de classe (variable).
- **Constructeur/Destructeur** : ce sont deux m√©thodes appel√©es syst√©matiquement lors de la cr√©ation (instanciation) d'un objet et de sa destruction (lib√©ration). Le constructeur porte le m√™me nom que la classe, le destructeur √©galement, mais pr√©c√©d√© du signe `~`.

> L'encapsulation consiste √† masquer l'acc√®s √† certains attributs et m√©thodes d'une classe. Elle est r√©alis√©e √† l'aide des mots cl√©s :
>
>- `private` : les membres priv√©s ne sont accessibles que par les fonctions membres de la classe. La partie priv√©e est aussi appel√©e r√©alisation.
>- `protected` : les membres prot√©g√©s sont comme les membres priv√©s. Mais ils sont aussi accessibles par les fonctions membres des classes d√©riv√©es (voir l'h√©ritage).
>- `public` : les membres publics sont accessibles par tous. La partie publique est appel√©e interface.
Les mots r√©serv√©s private, protected et public peuvent figurer plusieurs fois dans la d√©claration de la classe.


```cpp
#include <iostream>
using namespace std;

class MaClasse {       // La classe
¬† public:              // Sp√©cifieur d'acc√®s
¬†¬†¬† int nombre;        // Attribut (int variable)
¬†¬†¬† string chaine;     // Attribut (string variable)
};

int main() {
¬† MaClasse objet;¬† // Cr√©er un objet de MaClasse

¬† // Acc√®s aux attributs et d√©finition des valeurs
¬† objet.nombre = 12;¬†
¬† objet.chaine = "BTS CIEL";

¬† // Affichage des valeurs des attributs
¬† cout << objet.nombre<< "\n"; 
¬† cout << objet.chaine; 
¬† return 0;
}
```

## Exemple 1

```cpp
#include <iostream>
using namespace std;

class Ordinateur {
    public:
    string marque;
    int annee;
    int prix;

    public:
    void printDetails(){
        cout << "Marque : " << marque << endl;
        cout << "Ann√©e de sortie : " << annee << endl;
        cout << "Prix : " << prix << endl;
    }
};

int main() {
   //cr√©ation d'un objet de la classe
   Ordinateur ordi_1;

   //modification des attributs de l'objet
   ordi_1.marque = "Apple";
   ordi_1.annee = 2025;
   ordi_1.prix = 2300;

   //Appel de la fonction
   ordi_1.printDetails();
}
```

## Exemple 1 : avec constructeur

```cpp
#include <iostream>
using namespace std;

class Ordinateur {
   public:
   string marque;
   int annee;
   int prix;

   //constructeur
   Ordinateur(string x, int y, int z) {
      marque = x;
      annee = y;
      prix = z;
   }

   public:
   void printDetails(){
      cout << "Marque : " << marque << endl;
      cout << "Ann√©e de sortie : " << annee << endl;
      cout << "Prix : " << prix << endl;
   }
};

int main() {
   //cr√©er un objet de classe avec un appel au constructeur
   Ordinateur ordi_1("Apple", 2025, 2300);

   //Appel de la fonction
   ordi_1.printDetails();
}
```


# Diagramme de classe (UML)

La classe est d√©finie par son nom, ses attributs et ses op√©rations (m√©thodes). √âtant donn√© que les classes vont √™tre utilis√©es pour g√©n√©rer le code, il est souhaitable d'utiliser une r√®gle de nommage qui respecte les syntaxes des langages informatiques :

- Les noms des classes commencent par des majuscules et tous les autres √©l√©ments par des minuscules.
- S√©parer les mots compos√©s par des majuscules.
- Ne pas utiliser de caract√®res sp√©ciaux ou accentu√©s qui pourraient ne pas √™tre accept√©s dans les langages informatiques.

<table>
<tr>
  <th></th>
  </tr>
  <tr>
    <th>NomDeLaClasse</th>
  </tr>

  <tr style="color:#4488EE">
    <td>-nomAttribut1</td>
  </tr>
  <tr style="color:#4488EE">
    <td>-nomAttribut2: type</td>
  </tr>
  <tr>
    <td style="color:#4488EE">-nomAttribut2: type = valeur</td>
  </tr>

  <tr>
  <th></th>
  </tr>
  <tr style="color:#EE8844">
    <td>+nomOperation1()</td>
  </tr>
  <tr style="color:#EE8844">
    <td>#nomOperation2(parametre1)</td>
  </tr>
  <tr style="color:#EE8844">
    <td>-nomOperation3(parametre2: type,parametre3: type)</td>
  </tr>
  <tr style="color:#EE8844">
    <td>#nomOperation4(): typeRetour</td>
  </tr>
  <tr style="color:#EE8844">
    <td>-nomOperation5(parametre2: type, parametre3: type): typeRerour2:typeRetour</td>
  </tr>
  <tr>
  <th></th>
  </tr>
 </table>

### Attributs de classe¬†:

- Les attributs sont affich√©s dans la deuxi√®me partie.
- Le type d‚Äôattribut est affich√© apr√®s les deux-points.

### Op√©rations de classe (m√©thodes)¬†:

- Les op√©rations sont pr√©sent√©es dans la troisi√®me partie.¬†Ce sont des services que la classe fournit.
- Le type de retour d‚Äôune m√©thode est affich√© apr√®s les deux-points √† la fin de la signature de la m√©thode.
- Le type de retour des param√®tres de m√©thode est affich√© apr√®s les deux-points suivant le nom du param√®tre.

---

### Programme : Attribut priv√© ("private")

```cpp
#include <iostream>
using namespace std;
 
class Rectangle {
   public:
      double longueur;
      //! La largeur du rectangle est "priv√©e (private)"
      //! Il est n√©cessaire d'utiliser un "setter" et un "getter" pour acc√©der √† la largeur
      void setLargeur( double lar ); // Fonction pour : d√©finir (fixer) la largeur
      double getLargeur( void ); // Fonction pour : obtenir (r√©cup√©rer) la largeur
 
   private:
      double largeur;
};
 
// D√©finitions des fonctions memebres
double Rectangle::getLargeur(void) {
   return largeur ;
}
 
void Rectangle::setLargeur( double lar ) {
   largeur = lar;
}
 
// fonction main() du programme
int main() {
   Rectangle rectangle1; // Objet rectangle1
 
   // d√©finir la longueur ("public") du rectangle sans fonction membre
   rectangle1.longueur = 12.0; // Juste : parce que la longueur est publique
   cout << "Longueur du rectangle : " << rectangle1.longueur <<endl;
 
   // d√©finir la largeur ("private") de la bo√Æte sans fonction membre : impossible
   // rectangle1.largeur = 10.0; // Erreur¬†: car la largeur est priv√©e
   rectangle1.setLargeur(10.0);  // Utiliser la fonction membre "setter" pour la d√©finir.
   cout << "Largeur du rectangle : " << rectangle1.getLargeur() <<endl;
 
   return 0;
}
```

### Programme : Objet statique

```cpp
#include <iostream>
using namespace std;

class Rectangle {
   public:
    static int objetCount;

    // D√©finition du constructeur
    Rectangle(double L = 2.0, double l = 3.0) {
      cout <<"Constructeur appel√©." << endl;
      longueur = L;
      largeur = l;

      // Incr√©menter √† chaque fois qu'un objet est cr√©√©
      objetCount++;
    }
    double Surface() {
      return longueur * largeur;
    }
      
   private:
    double longueur;   // Longueur du rectangle
    double largeur;    // Largeur du rectangle
};

// Initialiser le membre statique de la classe Rectangle
int Rectangle::objetCount = 0;

int main(void) {
  Rectangle Rectangle1(3.14, 2.5);   // D√©clarer Rectangle1
  Rectangle Rectangle2(4.9, 6.2);    // D√©clarer Rectangle2

  // Afficher le nombre total d'objets.
  cout << "Total des objets: " << Rectangle::objetCount << endl;

  return 0;
}
```

### Exemple (Constructeur)

```cpp
#include <iostream>
using namespace std;
 
class Rectangle {
   public:
      double longueur;
      double largeur;
      // Constructeur par d√©faut vide
      //Rectangle() {}
      //

     // Constructeur par d√©faut
      //Rectangle() {
      //   longueur = 0;
      //   largeur = 0;
      //}


      // Constructeur param√©tr√©     
      Rectangle(double L, double l) {
        longueur = L;
        largeur = l;
      }

      void AffichageResultat() {
        cout << "La longueur du rectangle est : " << longueur << endl;
        cout << "La largeur du rectangle est : " << largeur << endl;
        cout << "La surface du rectangle est : " << longueur*largeur << endl;
      }
};
 
// fonction main() du programme
int main() {
   Rectangle rectangle1(12,10); // Objet rectangle1
   rectangle1.AffichageResultat();
 
   return 0;
}
```

### Exemple (Destructeur)

```cpp
#include <iostream>
using namespace std;
 
class Rectangle {
   public:
      double longueur;
      double largeur;

      // Constructeur   
      Rectangle(double L, double l) {
        longueur = L;
        largeur = l;
        cout << "Le constructeur du rectangle " << longueur << "x" << largeur << " est appel√©" <<endl;
      }
      // Destructeur
      ~Rectangle() {
         cout << "Le destructeur du rectangle " << longueur << "x" << largeur << " est appel√©" <<endl;
      }
      // Copie constructeur
      Rectangle(const Rectangle& original) {
         longueur = original.longueur;
         largeur = original.largeur;
      }

      void AffichageResultat() {
        cout << "La longueur du rectangle est : " << longueur << endl;
        cout << "La largeur du rectangle est : " << largeur << endl;
        cout << "La surface du rectangle est : " << longueur*largeur << endl;
      }
};
 
// fonction main() du programme
int main() {
   Rectangle rectangle1(12,10); // Objet rectangle1
   rectangle1.AffichageResultat();
   Rectangle rectangle2(212,210); // Objet rectangle2
   rectangle2.AffichageResultat();

   Rectangle rectangle3(rectangle1); // Objet rectangle3
   rectangle3.AffichageResultat();
 
   return 0;
}
```

---

# H√©ritage

L‚Äôh√©ritage est un m√©canisme cl√© de la programmation orient√©e objet qui permet de cr√©er des relations hi√©rarchiques entre les classes.

Lorsqu'une relation d'h√©ritage est d√©finie entre deux classes, la sous-classe h√©rite de tous les attributs et m√©thodes de la classe m√®re. C'est √† dire que tout se passe comme si les attributs et m√©thodes de la classe m√®re avaient √©t√© explicitement d√©finies pour la sous-classe. 

Une sous-classe d'une classe donn√©e repr√©sente donc une sorte de cas particulier de cette classe qui poss√®de des attributs et m√©thodes suppl√©mentaires et sp√©cifiques.

L'h√©ritage √©vite d'avoir √† r√©√©crire le m√™me code √† plusieurs reprises. Un anc√™tre peut transmettre des propri√©t√©s √† tous ses descendants. En termes de codage, cela peut nous faire √©conomiser beaucoup de temps et de travail.


- Classe de base - La classe dont les propri√©t√©s et les fonctionnalit√©s sont utilis√©es par une autre classe est appel√©e la classe de base (super-classe, classe m√®re ...).
- Classe d√©riv√©e - La classe qui reprend les propri√©t√©s et les fonctionnalit√©s d‚Äôune autre classe est appel√©e la classe d√©riv√©e. (sous-classe ...).

<center>
<img width="300" alt="Diagramme" src="d.png">
</center>

### Programme : Attribut prot√©g√© ("protected")

```cpp
#include <iostream>
using namespace std;
 
class Rectangle {
   protected:
      double largeur;
};
 
class Carre:Rectangle { // Carre est la classe d√©riv√©e.
   public:
      void setCarreLargeur( double lar );
      double getCarreLargeur( void );
};
 
// Fonctions membres de la classe enfant (d√©riv√©e)
double Carre::getCarreLargeur(void) {
   return largeur ;
}
 
void Carre::setCarreLargeur( double lar ) {
   largeur = lar;
}

int main() {
   Carre carre1;
 
   // d√©finir la largeur du rectangle (carr√©) √† l'aide de la fonction membre
   carre1.setCarreLargeur(5.0);
   cout << "Largeur du carr√© : "<< carre1.getCarreLargeur() << endl;
 
   return 0;
}
```

### Constructeur par d√©faut

```cpp
#include <iostream>
using namespace std;
 
class Base {
  int x;
  public:
    // Constructeur par d√©faut
    Base() {
      cout << "Constructeur par d√©faut de la classe de base" << endl;
    }
};
 
class Herite : public Base {
  int y;
  public:
    // Constructeur par d√©faut
    Herite() {
      cout << "Constructeur par d√©faut de la classe deriv√©e" << endl;
    }
    // Constructeur param√©tr√©
    Herite(int i) {
      cout << "Constructeur param√©tr√© de la classe deriv√©e\n";
    }
};
 
int main()
{
    Herite d1;
    Herite d2(12);
}
```

```cpp
#include <iostream>
#include <string>
using namespace std;

class Rectangle {
 public:
  int L;
  int l;
};
class Carre : public Rectangle {
 public:
  int surface() { return L * L; }
};
int main() {
  Carre c;
  c.L = 5;
  cout << "Area: " << s.surface() << endl;
  return 0;
}
```


---

<kbd>cmd + shift + p</kbd>

<kbd>‚ÄÉ[GitHub](https://github.com/boudjelaba) ‚ÜóÔ∏è‚ÄÉ</kbd>

[:arrow_up:](#top)

:exclamation: test

:question: test

:bust_in_silhouette: test

:mag: test

:date: test

:arrow_down: test

:arrow_left: test 

:arrow_right: test

:ok: test

:cl: test

:negative_squared_cross_mark: test


